# Лабораторная работа 2
Возьмем пример с контейнеризацией какой-то обученной ML-модели.


```
FROM ubuntu:latest

RUN apt-get update 
RUN apt-get install -y python3.9 python3-pip

WORKDIR /app

COPY predict.py .
COPY /local_model ./local_model
COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

#подразумевается что predict.py отслеживает stdin
CMD ["python3", "predict.py"]
```


Исправленная версия:

```
FROM python:3.9-slim

WORKDIR /app

COPY requirements.txt .
RUN pip install --no-cache-dir -r requirements.txt

COPY /local_model ./local_model
COPY predict.py .

RUN groupadd -r appuser && useradd -r -g appuser appuser && \
    mkdir -p /app /home/appuser/.cache && \
    chown -R appuser:appuser /app /home/appuser/

USER appuser

ENTRYPOINT ["python3", "predict.py"]
```


## Что изменилось:

1. Стандартный образ ubuntu предоставляет широкий функционал и пространство для взаимодействия пользователя с контейнером. Возможно, он мог бы пригодиться в начале докерфайла для крупного проекта, где пригодились бы разные настройки, пакеты, а следовательно, и многостадийная сборка. Но для работы модели не нужен полный образ ubuntu, или даже обычный python образ, поэтому берем потенциально минимальный, для оптимизации использования памяти.
2. В данном случае потенциальному пользователю не необходимы права root в контейнере, их следует ограничить из общих соображений потенциального ущерба уязвимостей кода или пакетов. Во второй версии пространства для потенциальной атаки сокращено, так как создан пользователь appuser с ограниченными правами.
3. При использовании CMD есть возможность поменять команды в интерактивном режиме. При этом сущность модели не предполагает дообучения, а взаимодействие с ней происходит благодаря логике predict.py - контейнер предназначен для выполнения одной задачи. Поэтому, чтобы исключить потенциальное взаимодействие с контейнером (тут скорее с точки зрения ошибки пользователя, нежели из соображений безопасности), заменим CMD на ENTRYPOINT.
4. Изменился порядок копирования файлов - от наиболее стабильным к наиболее часто изменяемым. Это важно для эффективного использования системы кеширования Docker, так как Docker кеширует результат каждой команды как отдельный слой, то есть при изменении одного файла (например, predict.py) пересобираются только слои, зависящие от этого файла. Из-за этого же установка зависимостей происходит в первую очередь, иначе тяжеловесные библиотеки (такие как pytorch в нашем случае) будут устанавливаться как новый слой при каждом изменении программы. Также команды RUN объединены в одну там, где это возможно, чтобы не создавать дополнительные слои образа.
5. Использование тега latest - не лучший вариант, так как без указания конкретной версии могут возникнуть конфликты зависимостей (так и произошло с версией python 3.9, которой нет в основных репозиториях последней версии ubuntu)
<img width="1877" height="616" alt="image" src="https://github.com/user-attachments/assets/ad801095-02a2-4404-8e61-d68a1907ace3" />


## Сборка образа и запуск контейнера:
<img width="1876" height="461" alt="image" src="https://github.com/user-attachments/assets/ebddffb3-1cad-490d-b572-ed4f5f9e88b0" />
<img width="1473" height="181" alt="image" src="https://github.com/user-attachments/assets/4e215b77-14c3-43cf-81e7-a40a4b304d3b" />


Немного изменим программу.
При повторном запуске build видно, что время сборки сильно меньше, так как слой с установленными зависимостями и моделью подтягивается из кеша. В первом варианте они устанавливались бы заново.
<img width="1882" height="688" alt="image" src="https://github.com/user-attachments/assets/4aa83d36-9306-45f2-8d08-724f0115b19f" />



### Плохие практики работы с контейнерами:
1. Подключать автоматический запуск всех или даже немногих потенциально полезных приложений в контейнерах при запуске системы. Оперативной памяти не всегда бывает много, а при большом количестве разного рода задач можно и не заметить лишний раз, что на фоне есть запущенные контейнеры. Кроме того, на некоторых системах из-за этого могут потенциально возникать конфликты при дублировании  классическим образом установленных приложений и приложений в контейнерах.
2. Ручная модификация окружения в рантайме. Это нарушает принцип воспроизводимости и приводит к тому, что разные инстансы контейнера могут содержать различные версии пакетов и настройки, не исключены конфликты версий зависимостей и конфигурации, а при отладке сложно определить, какое именно изменение вызвало проблему. Все зависимости и настройки должны быть явно объявлены в Dockerfile, в результате чего получаем детерминированную сборку, идентичные окружения для всех инстансов, упрощение CI/CD и отладки.
3. Хранение данных в контейнере. Контейнеры являются временными и могут быть пересозданы в любой момент, поэтому все данные, сохраненные в их файловой системе, безвозвратно теряются при остановке или удалении контейнера. Это делает невозможным обновление приложения без потери данных, усложняет масштабирование и создает риск потери критически важной информации. Чтобы этого избежать, нужно использовать управляемые хранилища (Docker Volumes) либо подключиться к внешней базе данных.
