# Лабораторная работа 2
Возьмем пример с контейнеризацией какой-то обученной ML-модели.


```
FROM ubuntu:latest

RUN apt-get update 
RUN apt-get install -y python3.11 python3-pip

WORKDIR /app

COPY predict.py .
COPY model.pkl .
COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

#подразумевается что predict.py отслеживает stdin
CMD ["python3", "predict.py"]
```


Исправленная версия:

```
FROM  python:3.11-slim

WORKDIR /app

COPY requirements.txt .

RUN pip install --no-cache-dir -r requirements.txt

COPY model.pkl .
COPY predict.py .

RUN groupadd -r appuser && useradd -r -g appuser appuser && \
    chown -R appuser:appuser /app

USER appuser

ENTRYPOINT ["python3", "predict.py"]
```


## Что изменилось:

1. Стандартный образ ubuntu предоставляет широкий функционал и пространство для взаимодействия пользователя с контейнером. Возможно, он мог бы пригодиться в начале докерфайла для крупного проекта, где пригодились бы разные настройки, пакеты, а следовательно, и многостадийная сборка. Но для работы модели не нужен полный образ ubuntu, или даже обычный python образ, поэтому берем потенциально минимальный, для оптимизации использования памяти.
2. В данном случае потенциальному пользователю не необходимы права root в контейнере, их следует ограничить из общих соображений потенциального ущерба уязвимостей кода или пакетов. Во второй версии пространства для потенциальной атаки сокращено, так как создан пользователь aapuser с ограниченными правами.
3. При использовании CMD есть возможность поменять команды в интерактивном режиме. При этом сущность модели не предполагает дообучения, а взаимодействие с ней происходит благодаря логике predict.py - контейнер предназначен для выполнения одной задачи. Поэтому, чтобы исключить потенциальное взаимодействие с контейнером (тут скорее с точки зрения ошибки пользователя, нежели из соображений безопасности), заменим CMD на ENTRYPOINT.
4. Изменился порядок копирования файлов - от наиболее стабильным к наиболее часто изменяемым. Это важно для эффективного использования системы кеширования Docker. Docker кеширует результат каждой команды как отдельный слой, то есть при изменении только одного файла (например, predict.py) пересобираются только слои, зависящие от этого файла. Раздельное копирование более-менее стабильных файлов (зависимости, модель) и часто меняющегося кода позволяет максимально использовать кеш и ускорить разработку. Также команды RUN объединены в одну там, где это возможно, чтобы не создавать дополнительные слои образа.

### Плохие практики работы с контейнерами:
1. Подключать автоматический запуск всех или даже немногих потенциально полезных приложений в контейнерах при запуске системы. Оперативной памяти не всегда бывает много, а при большом количестве разного рода задач можно и не заметить лишний раз, что на фоне есть запущенные контейнеры. Кроме того, на некоторых системах из-за этого могут потенциально возникать конфликты при дублировании  классическим образом установленных приложений и приложений в контейнерах.
2. Ручная модификация окружения в рантайме. Это нарушает принцип воспроизводимости и приводит к тому, что разные инстансы контейнера могут содержать различные версии пакетов и настройки, не исключены конфликты версий зависимостей и конфигурации, а при отладке сложно определить, какое именно изменение вызвало проблему. Все зависимости и настройки должны быть явно объявлены в Dockerfile, в результате чего получаем детерминированную сборку, идентичные окружения для всех инстансов, упрощение CI/CD и отладки.
3. Хранение данных в контейнере. Контейнеры являются временными и могут быть пересозданы в любой момент, поэтому все данные, сохраненные в их файловой системе, безвозвратно теряются при остановке или удалении контейнера. Это делает невозможным обновление приложения без потери данных, усложняет масштабирование и создает риск потери критически важной информации. Чтобы этого избежать, нужно использовать управляемые хранилища (Docker Volumes) либо подключиться к внешней базе данных.
